-- Create user roles enum
CREATE TYPE public.app_role AS ENUM ('admin', 'member');

-- Create account status enum
CREATE TYPE public.account_status_type AS ENUM ('active', 'suspended', 'closed');

-- Create loan status enum
CREATE TYPE public.loan_status_type AS ENUM ('active', 'returned', 'overdue');

-- ============================================
-- PROFILES TABLE
-- ============================================
CREATE TABLE public.profiles (
    id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    email TEXT,
    first_name TEXT,
    last_name TEXT,
    library_card_id TEXT UNIQUE,
    role public.app_role DEFAULT 'member',
    total_fines DECIMAL(10, 2) DEFAULT 0.00,
    account_status public.account_status_type DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

-- Enable Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- RLS Policies for profiles
CREATE POLICY "Users can view own profile" 
ON public.profiles FOR SELECT 
USING (auth.uid() = id);

CREATE POLICY "Admins can view all profiles" 
ON public.profiles FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
  )
);

CREATE POLICY "Users can update own profile" 
ON public.profiles FOR UPDATE 
USING (auth.uid() = id);

CREATE POLICY "Admins can update all profiles" 
ON public.profiles FOR UPDATE 
USING (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
  )
);

-- Trigger to auto-create profile on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, first_name, last_name, library_card_id)
  VALUES (
    NEW.id, 
    NEW.email, 
    COALESCE(NEW.raw_user_meta_data->>'first_name', ''),
    COALESCE(NEW.raw_user_meta_data->>'last_name', ''),
    'LIB-' || SUBSTR(NEW.id::text, 1, 8)
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- ============================================
-- CATEGORIES TABLE
-- ============================================
CREATE TABLE public.categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW())
);

ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

-- Everyone can view categories
CREATE POLICY "Public can view categories" 
ON public.categories FOR SELECT 
USING (true);

-- Only admins can modify categories
CREATE POLICY "Admins can modify categories" 
ON public.categories FOR ALL 
USING (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
  )
);

-- ============================================
-- BOOKS TABLE
-- ============================================
CREATE TABLE public.books (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    isbn TEXT UNIQUE NOT NULL,
    title TEXT NOT NULL,
    author TEXT NOT NULL,
    category_id BIGINT REFERENCES public.categories(id) ON DELETE SET NULL,
    description TEXT,
    publication_year INTEGER,
    total_copies INTEGER DEFAULT 1 CHECK (total_copies >= 0),
    available_copies INTEGER DEFAULT 1 CHECK (available_copies >= 0),
    cover_image_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()),
    CONSTRAINT check_availability CHECK (available_copies <= total_copies)
);

-- Indexes for performance
CREATE INDEX idx_books_title ON public.books(title);
CREATE INDEX idx_books_isbn ON public.books(isbn);
CREATE INDEX idx_books_author ON public.books(author);
CREATE INDEX idx_books_category ON public.books(category_id);

ALTER TABLE public.books ENABLE ROW LEVEL SECURITY;

-- Everyone can view books
CREATE POLICY "Public can view books" 
ON public.books FOR SELECT 
USING (true);

-- Only admins can modify books
CREATE POLICY "Admins can modify books" 
ON public.books FOR ALL 
USING (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
  )
);

-- ============================================
-- LOANS TABLE
-- ============================================
CREATE TABLE public.loans (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    book_id BIGINT REFERENCES public.books(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    issue_date TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', NOW()) NOT NULL,
    due_date TIMESTAMP WITH TIME ZONE NOT NULL,
    return_date TIMESTAMP WITH TIME ZONE,
    status public.loan_status_type DEFAULT 'active',
    notes TEXT,
    fine_amount DECIMAL(10, 2) DEFAULT 0.00
);

-- Index for querying user's loans
CREATE INDEX idx_loans_user_status ON public.loans(user_id, status);
CREATE INDEX idx_loans_book ON public.loans(book_id);
CREATE INDEX idx_loans_due_date ON public.loans(due_date);

ALTER TABLE public.loans ENABLE ROW LEVEL SECURITY;

-- Users can view their own loans
CREATE POLICY "Users view own loans" 
ON public.loans FOR SELECT 
USING (auth.uid() = user_id);

-- Admins can view all loans
CREATE POLICY "Admins view all loans" 
ON public.loans FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
  )
);

-- Admins can modify loans
CREATE POLICY "Admins modify loans" 
ON public.loans FOR ALL 
USING (
  EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
  )
);

-- ============================================
-- BUSINESS LOGIC: ISSUE BOOK FUNCTION
-- ============================================
CREATE OR REPLACE FUNCTION public.issue_book_transaction(
    p_book_id BIGINT, 
    p_user_id UUID,
    p_due_date TIMESTAMP WITH TIME ZONE
)
RETURNS JSONB AS $$
DECLARE
    v_available INT;
    v_loan_id BIGINT;
    v_account_status public.account_status_type;
BEGIN
    -- Check user account status
    SELECT account_status INTO v_account_status 
    FROM public.profiles 
    WHERE id = p_user_id;
    
    IF v_account_status != 'active' THEN
        RETURN jsonb_build_object('success', false, 'message', 'Account is not active');
    END IF;

    -- Lock the row for update to prevent race conditions
    SELECT available_copies INTO v_available 
    FROM public.books 
    WHERE id = p_book_id 
    FOR UPDATE;

    IF v_available > 0 THEN
        -- Decrement Inventory
        UPDATE public.books 
        SET available_copies = available_copies - 1 
        WHERE id = p_book_id;

        -- Create Loan
        INSERT INTO public.loans (book_id, user_id, due_date)
        VALUES (p_book_id, p_user_id, p_due_date)
        RETURNING id INTO v_loan_id;

        RETURN jsonb_build_object('success', true, 'loan_id', v_loan_id);
    ELSE
        RETURN jsonb_build_object('success', false, 'message', 'Book unavailable');
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- BUSINESS LOGIC: RETURN BOOK FUNCTION
-- ============================================
CREATE OR REPLACE FUNCTION public.return_book_transaction(
    p_loan_id BIGINT
)
RETURNS JSONB AS $$
DECLARE
    v_book_id BIGINT;
    v_user_id UUID;
    v_due_date TIMESTAMP WITH TIME ZONE;
    v_fine DECIMAL(10, 2);
BEGIN
    -- Get loan details
    SELECT book_id, user_id, due_date 
    INTO v_book_id, v_user_id, v_due_date
    FROM public.loans 
    WHERE id = p_loan_id AND status = 'active';

    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'message', 'Loan not found or already returned');
    END IF;

    -- Calculate fine if overdue (Â£0.50 per day)
    v_fine := 0;
    IF NOW() > v_due_date THEN
        v_fine := GREATEST(0, EXTRACT(DAY FROM (NOW() - v_due_date)) * 0.50);
    END IF;

    -- Update loan record
    UPDATE public.loans 
    SET 
        return_date = NOW(),
        status = 'returned',
        fine_amount = v_fine
    WHERE id = p_loan_id;

    -- Increment available copies
    UPDATE public.books 
    SET available_copies = available_copies + 1 
    WHERE id = v_book_id;

    -- Update user's total fines
    IF v_fine > 0 THEN
        UPDATE public.profiles 
        SET total_fines = total_fines + v_fine 
        WHERE id = v_user_id;
    END IF;

    RETURN jsonb_build_object('success', true, 'fine', v_fine);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- TRIGGER: UPDATE TIMESTAMP
-- ============================================
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = TIMEZONE('utc', NOW());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();

-- ============================================
-- SEED DATA: CATEGORIES
-- ============================================
INSERT INTO public.categories (name, description) VALUES
    ('Fiction', 'Literary works of imagination'),
    ('Non-Fiction', 'Factual and informational books'),
    ('Science Fiction', 'Speculative fiction based on science and technology'),
    ('Mystery', 'Detective and crime fiction'),
    ('Biography', 'Life stories and memoirs'),
    ('History', 'Historical accounts and analysis'),
    ('Science', 'Scientific literature and research'),
    ('Technology', 'Computing and technological advancement');

-- ============================================
-- STORAGE: BOOK COVERS BUCKET
-- ============================================
INSERT INTO storage.buckets (id, name, public) 
VALUES ('book-covers', 'book-covers', true)
ON CONFLICT (id) DO NOTHING;

-- Storage RLS: Public Read
CREATE POLICY "Public Access to Book Covers" 
ON storage.objects FOR SELECT 
USING (bucket_id = 'book-covers');

-- Storage RLS: Admin Upload
CREATE POLICY "Admin Upload Book Covers" 
ON storage.objects FOR INSERT 
WITH CHECK (
    bucket_id = 'book-covers' 
    AND EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
);

-- Storage RLS: Admin Delete
CREATE POLICY "Admin Delete Book Covers" 
ON storage.objects FOR DELETE 
USING (
    bucket_id = 'book-covers' 
    AND EXISTS (
        SELECT 1 FROM public.profiles 
        WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
);